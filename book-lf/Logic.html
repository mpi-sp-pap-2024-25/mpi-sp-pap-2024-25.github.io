<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="common/css/sf.css" rel="stylesheet" type="text/css" />
<title>Logic: Logic in Coq: part 3</title>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>
</head>

<body>

<div id="page">

<div id="header">
<div id='logoinheader'><a href='https://softwarefoundations.cis.upenn.edu'>
<img src='common/media/image/sf_logo_sm.png' alt='Software Foundations Logo'></a></div>
<div class='booktitleinheader'><a href='index.html'>Volume 1: Logical Foundations</a></div>
<ul id='menu'>
   <li class='section_name'><a href='toc.html'>Table of Contents</a></li>
   <li class='section_name'><a href='coqindex.html'>Index</a></li>
   <li class='section_name'><a href='deps.html'>Roadmap</a></li>
</ul>
</div>

<div id="main">

<h1 class="libtitle">Logic: Logic in Coq<span class="subtitle">part 3</span></h1>



<div class="doc">
<a id="lab224"></a><h1 class="section">The Logic of Coq</h1>

<div class="paragraph"> </div>

 Coq's logical core, the <i>Calculus of Inductive
    Constructions</i>, differs in some important ways from other formal
    systems that are used by mathematicians to write down precise and
    rigorous definitions and proofs -- in particular from
    Zermelo-Fraenkel Set Theory (ZFC), the most popular foundation for
    paper-and-pencil mathematics.

<div class="paragraph"> </div>

    We conclude this chapter with a brief discussion of some of the
    most significant differences between these two worlds. 
<div class="paragraph"> </div>

<a id="lab225"></a><h2 class="section">Functional Extensionality</h2>

<div class="paragraph"> </div>

 Coq's logic is quite minimalistic.  This means that one occasionally
    encounters cases where translating standard mathematical reasoning into
    Coq is cumbersome -- or even impossible -- unless we enrich its core
    logic with additional axioms. 
<div class="paragraph"> </div>

 For example, the equality assertions that we have seen so far
    mostly have concerned elements of inductive types (<span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">bool</span></span>,
    etc.).  But, since Coq's equality operator is polymorphic, we can use
    it at <i>any</i> type -- in particular, we can write propositions claiming
    that two <i>functions</i> are equal to each other:  In certain cases Coq can successfully prove equality propositions stating
    that two <i>functions</i> are equal to each other: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="function_equality_ex<sub>1</sub>" class="idref" href="#function_equality_ex<sub>1</sub>"><span class="id" title="definition">function_equality_ex<sub>1</sub></span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <a id="x:1" class="idref" href="#x:1"><span class="id" title="binder">x</span></a> ⇒ 3 <a class="idref" href="Basics.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="Logic.html#x:1"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <a id="x:2" class="idref" href="#x:2"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="Basics.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#pred"><span class="id" title="abbreviation">pred</span></a> 4<a class="idref" href="Basics.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a> <a class="idref" href="Basics.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="Logic.html#x:2"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
This works when Coq can simplify the functions to the same expression,
    but this doesn't always work. 
<div class="paragraph"> </div>

 These two functions are equal just by simplification, but in general
    functions can be equal for more interesting reasons.

<div class="paragraph"> </div>

    In common mathematical practice, two functions <span class="inlinecode"><span class="id" title="var">f</span></span> and <span class="inlinecode"><span class="id" title="var">g</span></span> are
    considered equal if they produce the same output on every input:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">x</span>) → <span class="id" title="var">f</span> = <span class="id" title="var">g</span>
</span>    This is known as the principle of <i>functional extensionality</i>. 
<div class="paragraph"> </div>

 (Informally, an "extensional property" is one that pertains to an
    object's observable behavior.  Thus, functional extensionality
    simply means that a function's identity is completely determined
    by what we can observe from it -- i.e., the results we obtain
    after applying it.) 
<div class="paragraph"> </div>

 However, functional extensionality is not part of Coq's built-in logic.
    This means that some intuitively obvious propositions are not
    provable. 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="function_equality_ex<sub>2</sub>" class="idref" href="#function_equality_ex<sub>2</sub>"><span class="id" title="definition">function_equality_ex<sub>2</sub></span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <a id="x:3" class="idref" href="#x:3"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#plus"><span class="id" title="abbreviation">plus</span></a> <a class="idref" href="Logic.html#x:3"><span class="id" title="variable">x</span></a> 1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <a id="x:4" class="idref" href="#x:4"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#plus"><span class="id" title="abbreviation">plus</span></a> 1 <a class="idref" href="Logic.html#x:4"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">Fail</span> <span class="id" title="tactic">reflexivity</span>. <span class="id" title="var">Fail</span> <span class="id" title="tactic">rewrite</span> <a class="idref" href="Induction.html#add_comm"><span class="id" title="axiom">add_comm</span></a>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Stuck&nbsp;*)</span><br/>
<span class="id" title="keyword">Abort</span>.<br/>
</div>

<div class="doc">
However, if we like, we can add functional extensionality to Coq
    using the <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> command. 
</div>
<div class="code">

<span class="id" title="keyword">Axiom</span> <a id="functional_extensionality" class="idref" href="#functional_extensionality"><span class="id" title="axiom">functional_extensionality</span></a> : <span class="id" title="keyword">∀</span> {<a id="X:5" class="idref" href="#X:5"><span class="id" title="binder">X</span></a> <a id="Y:6" class="idref" href="#Y:6"><span class="id" title="binder">Y</span></a>: <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<a id="f:7" class="idref" href="#f:7"><span class="id" title="binder">f</span></a> <a id="g:8" class="idref" href="#g:8"><span class="id" title="binder">g</span></a> : <a class="idref" href="Logic.html#X:5"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#Y:6"><span class="id" title="variable">Y</span></a>},<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> (<a id="x:9" class="idref" href="#x:9"><span class="id" title="binder">x</span></a>:<a class="idref" href="Logic.html#X:5"><span class="id" title="variable">X</span></a>), <a class="idref" href="Logic.html#f:7"><span class="id" title="variable">f</span></a> <a class="idref" href="Logic.html#x:9"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Logic.html#g:8"><span class="id" title="variable">g</span></a> <a class="idref" href="Logic.html#x:9"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#f:7"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Logic.html#g:8"><span class="id" title="variable">g</span></a>.<br/>
</div>

<div class="doc">
Defining something as an <span class="inlinecode"><span class="id" title="keyword">Axiom</span></span> has the same effect as stating a
    theorem and skipping its proof using <span class="inlinecode"><span class="id" title="var">Admitted</span></span>, but it alerts the
    reader that this isn't just something we're going to come back and
    fill in later! 
<div class="paragraph"> </div>

 We can now invoke functional extensionality in proofs: 
</div>
<div class="code">

<span class="id" title="keyword">Example</span> <a id="function_equality_ex<sub>2</sub>" class="idref" href="#function_equality_ex<sub>2</sub>"><span class="id" title="definition">function_equality_ex<sub>2</sub></span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <a id="x:11" class="idref" href="#x:11"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#plus"><span class="id" title="abbreviation">plus</span></a> <a class="idref" href="Logic.html#x:11"><span class="id" title="variable">x</span></a> 1<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <a id="x:12" class="idref" href="#x:12"><span class="id" title="binder">x</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Peano.html#plus"><span class="id" title="abbreviation">plus</span></a> 1 <a class="idref" href="Logic.html#x:12"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Logic.html#functional_extensionality"><span class="id" title="axiom">functional_extensionality</span></a>. <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Induction.html#add_comm"><span class="id" title="axiom">add_comm</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Naturally, we need to be quite careful when adding new axioms into
    Coq's logic, as this can render it <i>inconsistent</i> -- that is, it may
    become possible to prove every proposition, including <span class="inlinecode"><span class="id" title="var">False</span></span>, <span class="inlinecode">2+2=5</span>,
    etc.!

<div class="paragraph"> </div>

    In general, there is no simple way of telling whether an axiom is safe
    to add: hard work by highly trained mathematicians is often required to
    establish the consistency of any particular combination of axioms.

<div class="paragraph"> </div>

    Fortunately, it is known that adding functional extensionality, in
    particular, <i>is</i> consistent. 
<div class="paragraph"> </div>

 To check whether a particular proof relies on any additional
    axioms, use the <span class="inlinecode"><span class="id" title="keyword">Print</span></span> <span class="inlinecode"><span class="id" title="keyword">Assumptions</span></span> command:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <span class="id" title="keyword">Assumptions</span> <span class="id" title="var">function_equality_ex<sub>2</sub></span>
</span>
</div>
<div class="code">
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Axioms:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;functional_extensionality&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall&nbsp;(X&nbsp;Y&nbsp;:&nbsp;Type)&nbsp;(f&nbsp;g&nbsp;:&nbsp;X&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;Y),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;X,&nbsp;f&nbsp;x&nbsp;=&nbsp;g&nbsp;x)&nbsp;<span class="nowrap"><span style='font-size:85%;'><span style='vertical-align:5%;'><span style='letter-spacing:-.2em;'>-</span></span>&gt;</span></span>&nbsp;f&nbsp;=&nbsp;g&nbsp;*)</span><br/>
</div>

<div class="doc">
(If you try this yourself, you may also see <span class="inlinecode"><span class="id" title="var">add_comm</span></span> listed as
    an assumption, depending on whether the copy of <span class="inlinecode"><span class="id" title="var">Tactics.v</span></span> in the
    local directory has the proof of <span class="inlinecode"><span class="id" title="var">add_comm</span></span> filled in.) 
<div class="paragraph"> </div>

<a id="lab226"></a><h4 class="section">Exercise: 4 stars, standard (tr_rev_correct)</h4>
 One problem with the definition of the list-reversing function <span class="inlinecode"><span class="id" title="var">rev</span></span>
    that we have is that it performs a call to <span class="inlinecode"><span class="id" title="var">app</span></span> on each step.  Running
    <span class="inlinecode"><span class="id" title="var">app</span></span> takes time asymptotically linear in the size of the list, which
    means that <span class="inlinecode"><span class="id" title="var">rev</span></span> is asymptotically quadratic.

<div class="paragraph"> </div>

    We can improve this with the following two-argument definition: 
</div>
<div class="code">

<span class="id" title="keyword">Fixpoint</span> <a id="rev_append" class="idref" href="#rev_append"><span class="id" title="definition">rev_append</span></a> {<a id="X:13" class="idref" href="#X:13"><span class="id" title="binder">X</span></a>} (<a id="l<sub>1</sub>:14" class="idref" href="#l<sub>1</sub>:14"><span class="id" title="binder">l<sub>1</sub></span></a> <a id="l<sub>2</sub>:15" class="idref" href="#l<sub>2</sub>:15"><span class="id" title="binder">l<sub>2</sub></span></a> : <a class="idref" href="Poly.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Logic.html#X:13"><span class="id" title="variable">X</span></a>) : <a class="idref" href="Poly.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Logic.html#X:13"><span class="id" title="variable">X</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Logic.html#l<sub>1</sub>:14"><span class="id" title="variable">l<sub>1</sub></span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Poly.html#2c60282cbb04e070c60ae01e76f3865a"><span class="id" title="notation">[]</span></a> ⇒ <a class="idref" href="Logic.html#l<sub>2</sub>:15"><span class="id" title="variable">l<sub>2</sub></span></a><br/>
&nbsp;&nbsp;| <span class="id" title="var">x</span> <a class="idref" href="Poly.html#:::x_'::'_x"><span class="id" title="notation">::</span></a> <span class="id" title="var">l<sub>1</sub>'</span> ⇒ <a class="idref" href="Logic.html#rev_append:16"><span class="id" title="definition">rev_append</span></a> <span class="id" title="var">l<sub>1</sub>'</span> (<span class="id" title="var">x</span> <a class="idref" href="Poly.html#:::x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="Logic.html#l<sub>2</sub>:15"><span class="id" title="variable">l<sub>2</sub></span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="tr_rev" class="idref" href="#tr_rev"><span class="id" title="definition">tr_rev</span></a> {<a id="X:18" class="idref" href="#X:18"><span class="id" title="binder">X</span></a>} (<a id="l:19" class="idref" href="#l:19"><span class="id" title="binder">l</span></a> : <a class="idref" href="Poly.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Logic.html#X:18"><span class="id" title="variable">X</span></a>) : <a class="idref" href="Poly.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Logic.html#X:18"><span class="id" title="variable">X</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#rev_append"><span class="id" title="definition">rev_append</span></a> <a class="idref" href="Logic.html#l:19"><span class="id" title="variable">l</span></a> <a class="idref" href="Poly.html#2c60282cbb04e070c60ae01e76f3865a"><span class="id" title="notation">[]</span></a>.<br/>
</div>

<div class="doc">
This version of <span class="inlinecode"><span class="id" title="var">rev</span></span> is said to be <i>tail-recursive</i>, because the
    recursive call to the function is the last operation that needs to be
    performed (i.e., we don't have to execute <span class="inlinecode">++</span> after the recursive
    call); a decent compiler will generate very efficient code in this
    case.

<div class="paragraph"> </div>

    Prove that the two definitions are indeed equivalent. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <a id="tr_rev_correct" class="idref" href="#tr_rev_correct"><span class="id" title="lemma">tr_rev_correct</span></a> : <span class="id" title="keyword">∀</span> <a id="X:20" class="idref" href="#X:20"><span class="id" title="binder">X</span></a>, @<a class="idref" href="Logic.html#tr_rev"><span class="id" title="definition">tr_rev</span></a> <a class="idref" href="Logic.html#X:20"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> @<a class="idref" href="Poly.html#rev"><span class="id" title="definition">rev</span></a> <a class="idref" href="Logic.html#X:20"><span class="id" title="variable">X</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab227"></a><h2 class="section">Classical vs. Constructive Logic</h2>

<div class="paragraph"> </div>

 We have seen that it is not possible to test whether or not a
    proposition <span class="inlinecode"><span class="id" title="var">P</span></span> holds while defining a Coq function.  You may be
    surprised to learn that a similar restriction applies in <i>proofs</i>!
    In other words, the following intuitive reasoning principle is not
    derivable in Coq: 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="excluded_middle" class="idref" href="#excluded_middle"><span class="id" title="definition">excluded_middle</span></a> := <span class="id" title="keyword">∀</span> <a id="P:21" class="idref" href="#P:21"><span class="id" title="binder">P</span></a> : <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#P:21"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="Logic.html#P:21"><span class="id" title="variable">P</span></a>.<br/>
</div>

<div class="doc">
To understand operationally why this is the case, recall
    that, to prove a statement of the form <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">Q</span></span>, we use the <span class="inlinecode"><span class="id" title="tactic">left</span></span>
    and <span class="inlinecode"><span class="id" title="tactic">right</span></span> tactics, which effectively require knowing which side
    of the disjunction holds.  But the universally quantified <span class="inlinecode"><span class="id" title="var">P</span></span> in
    <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span> is an <i>arbitrary</i> proposition, which we know
    nothing about.  We don't have enough information to choose which
    of <span class="inlinecode"><span class="id" title="tactic">left</span></span> or <span class="inlinecode"><span class="id" title="tactic">right</span></span> to apply, just as Coq doesn't have enough
    information to mechanically decide whether <span class="inlinecode"><span class="id" title="var">P</span></span> holds or not inside
    a function. 
<div class="paragraph"> </div>

 In the special case where we happen to know that <span class="inlinecode"><span class="id" title="var">P</span></span> is reflected in
    some boolean term <span class="inlinecode"><span class="id" title="var">b</span></span>, knowing whether it holds or not is trivial: we
    just have to check the value of <span class="inlinecode"><span class="id" title="var">b</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <a id="restricted_excluded_middle" class="idref" href="#restricted_excluded_middle"><span class="id" title="lemma">restricted_excluded_middle</span></a> : <span class="id" title="keyword">∀</span> <a id="P:22" class="idref" href="#P:22"><span class="id" title="binder">P</span></a> <a id="b:23" class="idref" href="#b:23"><span class="id" title="binder">b</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Logic.html#P:22"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="Logic.html#b:23"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Basics.html#true"><span class="id" title="constructor">true</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#P:22"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="Logic.html#P:22"><span class="id" title="variable">P</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> [] <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">left</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">right</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">discriminate</span> <span class="id" title="var">contra</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In particular, the excluded middle is valid for equations <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span>,
    between natural numbers <span class="inlinecode"><span class="id" title="var">n</span></span> and <span class="inlinecode"><span class="id" title="var">m</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <a id="restricted_excluded_middle_eq" class="idref" href="#restricted_excluded_middle_eq"><span class="id" title="lemma">restricted_excluded_middle_eq</span></a> : <span class="id" title="keyword">∀</span> (<a id="n:24" class="idref" href="#n:24"><span class="id" title="binder">n</span></a> <a id="m:25" class="idref" href="#m:25"><span class="id" title="binder">m</span></a> : <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#n:24"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="Logic.html#m:25"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">∨</span></a> <a class="idref" href="Logic.html#n:24"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> <a class="idref" href="Logic.html#m:25"><span class="id" title="variable">m</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="Logic.html#restricted_excluded_middle"><span class="id" title="lemma">restricted_excluded_middle</span></a> (<span class="id" title="var">n</span> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">m</span>) (<span class="id" title="var">n</span> <a class="idref" href="Basics.html#ad2ec4e405f68c46c0a176e3e94ae2e<sub>3</sub>"><span class="id" title="notation">=?</span></a> <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="Logic2.html#eqb_eq"><span class="id" title="lemma">eqb_eq</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Sadly, this trick only works for decidable propositions. 
<div class="paragraph"> </div>

 It may seem strange that the general excluded middle is not
    available by default in Coq, since it is a standard feature of familiar
    logics like ZFC.  But there is a distinct advantage in <i>not</i> assuming
    the excluded middle: statements in Coq make stronger claims than the
    analogous statements in standard mathematics.  Notably, a Coq proof of
    <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> always includes a particular value of <span class="inlinecode"><span class="id" title="var">x</span></span> for which we
    can prove <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> -- in other words, every proof of existence is
    <i>constructive</i>. 
<div class="paragraph"> </div>

 Logics like Coq's, which do not assume the excluded middle, are
    referred to as <i>constructive logics</i>.

<div class="paragraph"> </div>

    More conventional logical systems such as ZFC, in which the
    excluded middle does hold for arbitrary propositions, are referred
    to as <i>classical</i>. 
<div class="paragraph"> </div>

 The following example illustrates why assuming the excluded middle may
    lead to non-constructive proofs:

<div class="paragraph"> </div>

    <i>Claim</i>: There exist irrational numbers <span class="inlinecode"><span class="id" title="var">a</span></span> and <span class="inlinecode"><span class="id" title="var">b</span></span> such that <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">^</span>
    <span class="inlinecode"><span class="id" title="var">b</span></span> (<span class="inlinecode"><span class="id" title="var">a</span></span> to the power <span class="inlinecode"><span class="id" title="var">b</span></span>) is rational.

<div class="paragraph"> </div>

    <i>Proof</i>: It is not difficult to show that <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> is irrational.  If
    <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> is rational, it suffices to take <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> and
    we are done.  Otherwise, <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> is irrational.  In this
    case, we can take <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> and <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span>, since <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">b</span></span>
    <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode">(<span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">×</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>.  <font size=-2>&#9744;</font>

<div class="paragraph"> </div>

    Do you see what happened here?  We used the excluded middle to consider
    separately the cases where <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> <span class="inlinecode">^</span> <span class="inlinecode"><span class="id" title="var">sqrt</span></span> <span class="inlinecode">2</span> is rational and where it
    is not, without knowing which one actually holds!  Because of this, we
    finish the proof knowing that such <span class="inlinecode"><span class="id" title="var">a</span></span> and <span class="inlinecode"><span class="id" title="var">b</span></span> exist, but not knowing
    their actual values.

<div class="paragraph"> </div>

    As useful as constructive logic is, it does have its limitations: There
    are many statements that can easily be proven in classical logic but
    that have only much more complicated constructive proofs, and there are
    some that are known to have no constructive proof at all!  Fortunately,
    like functional extensionality, the excluded middle is known to be
    compatible with Coq's logic, allowing us to add it safely as an axiom.
    However, we will not need to do so here: the results that we cover can
    be developed entirely within constructive logic at negligible extra
    cost.

<div class="paragraph"> </div>

    It takes some practice to understand which proof techniques must be
    avoided in constructive reasoning, but arguments by contradiction, in
    particular, are infamous for leading to non-constructive proofs.
    Here's a typical example: suppose that we want to show that there
    exists <span class="inlinecode"><span class="id" title="var">x</span></span> with some property <span class="inlinecode"><span class="id" title="var">P</span></span>, i.e., such that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.  We start by
    assuming that our conclusion is false; that is, <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>. From
    this premise, it is not hard to derive <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.  If we manage
    to show that this intermediate fact results in a contradiction, we
    arrive at an existence proof without ever exhibiting a value of <span class="inlinecode"><span class="id" title="var">x</span></span> for
    which <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> holds!

<div class="paragraph"> </div>

    The technical flaw here, from a constructive standpoint, is that we
    claimed to prove <span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> using a proof of <span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span>.
    Allowing ourselves to remove double negations from arbitrary
    statements is equivalent to assuming the excluded middle law, as shown
    in one of the exercises below.  Thus, this line of reasoning cannot be
    encoded in Coq without assuming additional axioms. 
<div class="paragraph"> </div>

<a id="lab228"></a><h4 class="section">Exercise: 3 stars, standard (excluded_middle_irrefutable)</h4>
 Proving the consistency of Coq with the general excluded middle
    axiom requires complicated reasoning that cannot be carried out
    within Coq itself.  However, the following theorem implies that it
    is always safe to assume a decidability axiom (i.e., an instance
    of excluded middle) for any <i>particular</i> Prop <span class="inlinecode"><span class="id" title="var">P</span></span>.  Why?  Because
    the negation of such an axiom leads to a contradiction.  If <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" title="var">P</span></span>
    <span class="inlinecode">∨</span> <span class="inlinecode">¬<span class="id" title="var">P</span>)</span> were provable, then by <span class="inlinecode"><span class="id" title="var">de_morgan_not_or</span></span> as proved above,
    <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode">¬<span class="id" title="var">P</span></span> would be provable, which would be a contradiction. So, it
    is safe to add <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode">¬<span class="id" title="var">P</span></span> as an axiom for any particular <span class="inlinecode"><span class="id" title="var">P</span></span>.

<div class="paragraph"> </div>

    Succinctly: for any proposition P,
        <span class="inlinecode"><span class="id" title="var">Coq</span></span> <span class="inlinecode"><span class="id" title="keyword">is</span></span> <span class="inlinecode"><span class="id" title="var">consistent</span></span> <span class="inlinecode">==&gt;</span> <span class="inlinecode">(<span class="id" title="var">Coq</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode">¬<span class="id" title="var">P</span>)</span> <span class="inlinecode"><span class="id" title="keyword">is</span></span> <span class="inlinecode"><span class="id" title="var">consistent</span></span>. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <a id="excluded_middle_irrefutable" class="idref" href="#excluded_middle_irrefutable"><span class="id" title="lemma">excluded_middle_irrefutable</span></a>: <span class="id" title="keyword">∀</span> (<a id="P:26" class="idref" href="#P:26"><span class="id" title="binder">P</span></a> : <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">(</span></a><a class="idref" href="Logic.html#P:26"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="Logic.html#P:26"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab229"></a><h4 class="section">Exercise: 3 stars, advanced (not_exists_dist)</h4>
 It is a theorem of classical logic that the following two
    assertions are equivalent:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;¬(<span class="id" title="tactic">∃</span> <span class="id" title="var">x</span>, ¬<span class="id" title="var">P</span> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>
</span>    The <span class="inlinecode"><span class="id" title="var">dist_not_exists</span></span> theorem above proves one side of this
    equivalence. Interestingly, the other direction cannot be proved
    in constructive logic. Your job is to show that it is implied by
    the excluded middle. 
</div>
<div class="code">

<span class="id" title="keyword">Theorem</span> <a id="not_exists_dist" class="idref" href="#not_exists_dist"><span class="id" title="lemma">not_exists_dist</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#excluded_middle"><span class="id" title="definition">excluded_middle</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a id="X:27" class="idref" href="#X:27"><span class="id" title="binder">X</span></a>:<span class="id" title="keyword">Type</span>) (<a id="P:28" class="idref" href="#P:28"><span class="id" title="binder">P</span></a> : <a class="idref" href="Logic.html#X:27"><span class="id" title="variable">X</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a id="x:29" class="idref" href="#x:29"><span class="id" title="binder">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a> <a class="idref" href="Logic.html#P:28"><span class="id" title="variable">P</span></a> <a class="idref" href="Logic.html#x:29"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <a id="x:30" class="idref" href="#x:30"><span class="id" title="binder">x</span></a>, <a class="idref" href="Logic.html#P:28"><span class="id" title="variable">P</span></a> <a class="idref" href="Logic.html#x:30"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span> <span class="id" title="var">Admitted</span>.<br/>
<font size=-2>&#9744;</font>
</div>

<div class="doc"> 
<div class="paragraph"> </div>

<a id="lab230"></a><h4 class="section">Exercise: 5 stars, standard, optional (classical_axioms)</h4>
 For those who like a challenge, here is an exercise adapted from the
    Coq'Art book by Bertot and Casteran (p. 123).  Each of the
    following five statements, together with <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span>, can be
    considered as characterizing classical logic.  We can't prove any
    of them in Coq, but we can consistently add any one of them as an
    axiom if we wish to work in classical logic.

<div class="paragraph"> </div>

    Prove that all six propositions (these five plus <span class="inlinecode"><span class="id" title="var">excluded_middle</span></span>)
    are equivalent.

<div class="paragraph"> </div>

    Hint: Rather than considering all pairs of statements pairwise,
    prove a single circular chain of implications that connects them
    all. 
</div>
<div class="code">

<span class="id" title="keyword">Definition</span> <a id="peirce" class="idref" href="#peirce"><span class="id" title="definition">peirce</span></a> := <span class="id" title="keyword">∀</span> <a id="P:31" class="idref" href="#P:31"><span class="id" title="binder">P</span></a> <a id="Q:32" class="idref" href="#Q:32"><span class="id" title="binder">Q</span></a>: <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">((</span></a><a class="idref" href="Logic.html#P:31"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#Q:32"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#P:31"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#P:31"><span class="id" title="variable">P</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="double_negation_elimination" class="idref" href="#double_negation_elimination"><span class="id" title="definition">double_negation_elimination</span></a> := <span class="id" title="keyword">∀</span> <a id="P:33" class="idref" href="#P:33"><span class="id" title="binder">P</span></a>:<span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~~</span></a><a class="idref" href="Logic.html#P:33"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#P:33"><span class="id" title="variable">P</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="de_morgan_not_and_not" class="idref" href="#de_morgan_not_and_not"><span class="id" title="definition">de_morgan_not_and_not</span></a> := <span class="id" title="keyword">∀</span> <a id="P:34" class="idref" href="#P:34"><span class="id" title="binder">P</span></a> <a id="Q:35" class="idref" href="#Q:35"><span class="id" title="binder">Q</span></a>:<span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~(~</span></a><a class="idref" href="Logic.html#P:34"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a><a class="idref" href="Logic.html#Q:35"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#P:34"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">∨</span></a> <a class="idref" href="Logic.html#Q:35"><span class="id" title="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="implies_to_or" class="idref" href="#implies_to_or"><span class="id" title="definition">implies_to_or</span></a> := <span class="id" title="keyword">∀</span> <a id="P:36" class="idref" href="#P:36"><span class="id" title="binder">P</span></a> <a id="Q:37" class="idref" href="#Q:37"><span class="id" title="binder">Q</span></a>:<span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="Logic.html#P:36"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#Q:37"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a><a class="idref" href="Logic.html#P:36"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e<sub>25</sub>"><span class="id" title="notation">∨</span></a> <a class="idref" href="Logic.html#Q:37"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" title="keyword">Definition</span> <a id="consequentia_mirabilis" class="idref" href="#consequentia_mirabilis"><span class="id" title="definition">consequentia_mirabilis</span></a> := <span class="id" title="keyword">∀</span> <a id="P:38" class="idref" href="#P:38"><span class="id" title="binder">P</span></a>:<span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">¬</span></a><a class="idref" href="Logic.html#P:38"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#P:38"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/library//Coq.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="Logic.html#P:38"><span class="id" title="variable">P</span></a>.<br/><hr class='doublespaceincode'/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
<font size=-2>&#9744;</font>
</div>

<div class="code">

<span class="comment">(*&nbsp;2025-07-15&nbsp;10:52&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>